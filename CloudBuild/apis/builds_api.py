# coding: utf-8

"""
    Unity Cloud Build

    This API is intended to be used in conjunction with the Unity Cloud Build service. A tool for building your Unity projects in the Cloud.  See https://developer.cloud.unity3d.com for more information.  ## Making requests This website is built to allow requests to be made against the API. If you are currently logged into Cloud Build you should be able to make requests without entering an API key.   You can find your API key in the Unity Cloud Services portal by clicking on 'Cloud Build Preferences' in the sidebar. Copy the API Key and paste it into the upper left corner of this website. It will be used in all subsequent requests.  ## Clients The Unity Cloud Build API is based upon Swagger. Client libraries to integrate with your projects can easily be generated with the [Swagger Code Generator](https://github.com/swagger-api/swagger-codegen).  The JSON schema required to generate a client for this API version is located here:  ``` [API_URL][BASE_PATH]/api.json ```  ## Authorization The Unity Cloud Build API requires an access token from your Unity Cloud Build account, which can be found at https://build.cloud.unity3d.com/login/me  To authenticate requests, include a Basic Authentication header with your API key as the value. e.g.  ``` Authorization: Basic [YOUR API KEY] ```  ## Pagination Paged results will take two parameters. A page number that is calculated based upon the per_page amount. For instance if there are 40 results and you specify page 2 with per_page set to 10 you will receive records 11-20.  Paged results will also return a Content-Range header. For the example above the content range header would look like this:  ``` Content-Range: items 11-20/40 ```  ## Versioning The API version is indicated in the request URL. Upgrading to a newer API version can be done by changing the path.  The API will receive a new version in the following cases:    * removal of a path or request type   * addition of a required field   * removal of a required field  The following changes are considered backwards compatible and will not trigger a new API version:    * addition of an endpoint or request type   * addition of an optional field   * removal of an optional field   * changes to the format of ids  ## Rate Limiting Requests against the Cloud Build API are limited to a rate of 100 per minute. To preserve the quality of service throughout Cloud Build, additional rate limits may apply to some actions. For example, polling aggressively instead of using webhooks or making API calls with a high concurrency may result in rate limiting.  It is not intended for these rate limits to interfere with any legitimate use of the API. Please contact support at <cloudbuild@unity3d.com> if your use is affected by this rate limit.  You can check the returned HTTP headers for any API request to see your current rate limit status.   * __X-RateLimit-Limit:__ maximum number of requests per minute   * __X-RateLimit-Remaining:__ remaining number of requests in the current window   * __X-RateLimit-Reset:__ time at which the current window will reset (UTC epoch seconds)  Once you go over the rate limit you will receive an error response: ``` HTTP Status: 429 {   \"error\": \"Rate limit exceeded, retry in XX seconds\" } ``` 

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class BuildsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def batch_delete_build_artifacts(self, orgid, projectid, options, **kwargs):
        """
        Delete artifacts for a batch of builds
        Delete all artifacts associated with the builds identified by the provided build target ids and build numbers. Builds marked as do not delete or that are currently building will be ignored. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_delete_build_artifacts(orgid, projectid, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param Options10 options: Options to specify what builds to delete (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.batch_delete_build_artifacts_with_http_info(orgid, projectid, options, **kwargs)
        else:
            (data) = self.batch_delete_build_artifacts_with_http_info(orgid, projectid, options, **kwargs)
            return data

    def batch_delete_build_artifacts_with_http_info(self, orgid, projectid, options, **kwargs):
        """
        Delete artifacts for a batch of builds
        Delete all artifacts associated with the builds identified by the provided build target ids and build numbers. Builds marked as do not delete or that are currently building will be ignored. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_delete_build_artifacts_with_http_info(orgid, projectid, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param Options10 options: Options to specify what builds to delete (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'options']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_delete_build_artifacts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `batch_delete_build_artifacts`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `batch_delete_build_artifacts`")
        # verify the required parameter 'options' is set
        if ('options' not in params) or (params['options'] is None):
            raise ValueError("Missing the required parameter `options` when calling `batch_delete_build_artifacts`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'options' in params:
            body_params = params['options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/artifacts/delete', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def cancel_all_builds(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Cancel all builds
        Cancel all builds in progress for this build target (or all targets, if '_all' is specified as the buildtargetid). Canceling an already finished build will do nothing and respond successfully. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_all_builds(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_all_builds_with_http_info(orgid, projectid, buildtargetid, **kwargs)
        else:
            (data) = self.cancel_all_builds_with_http_info(orgid, projectid, buildtargetid, **kwargs)
            return data

    def cancel_all_builds_with_http_info(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Cancel all builds
        Cancel all builds in progress for this build target (or all targets, if '_all' is specified as the buildtargetid). Canceling an already finished build will do nothing and respond successfully. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_all_builds_with_http_info(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_all_builds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `cancel_all_builds`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `cancel_all_builds`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `cancel_all_builds`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def cancel_build(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Cancel build
        Cancel a build in progress. Canceling an already finished build will do nothing and respond successfully. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_build(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_build_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.cancel_build_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def cancel_build_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Cancel build
        Cancel a build in progress. Canceling an already finished build will do nothing and respond successfully. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_build_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_build" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `cancel_build`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `cancel_build`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `cancel_build`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `cancel_build`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def cancel_builds_for_org(self, orgid, **kwargs):
        """
        Cancel builds for org
        Cancel all in progress builds for an organization. Canceling an already finished build will do nothing and respond successfully. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_builds_for_org(orgid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_builds_for_org_with_http_info(orgid, **kwargs)
        else:
            (data) = self.cancel_builds_for_org_with_http_info(orgid, **kwargs)
            return data

    def cancel_builds_for_org_with_http_info(self, orgid, **kwargs):
        """
        Cancel builds for org
        Cancel all in progress builds for an organization. Canceling an already finished build will do nothing and respond successfully. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_builds_for_org_with_http_info(orgid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_builds_for_org" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `cancel_builds_for_org`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/builds', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_share(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Create a new link to share a project
        Create a new short link to share a project. If this is called when a share already exists, that share will be revoked and a new one created.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_share(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_share_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.create_share_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def create_share_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Create a new link to share a project
        Create a new short link to share a project. If this is called when a share already exists, that share will be revoked and a new one created.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_share_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `create_share`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `create_share`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `create_share`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `create_share`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InlineResponse20015',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_all_build_artifacts(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Delete all artifacts associated with all non-favorited builds for a specified buildtargetid (_all is allowed).
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_all_build_artifacts(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_all_build_artifacts_with_http_info(orgid, projectid, buildtargetid, **kwargs)
        else:
            (data) = self.delete_all_build_artifacts_with_http_info(orgid, projectid, buildtargetid, **kwargs)
            return data

    def delete_all_build_artifacts_with_http_info(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Delete all artifacts associated with all non-favorited builds for a specified buildtargetid (_all is allowed).
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_all_build_artifacts_with_http_info(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_build_artifacts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `delete_all_build_artifacts`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `delete_all_build_artifacts`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `delete_all_build_artifacts`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/artifacts', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_build_artifacts(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Delete all artifacts associated with a specific build
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_build_artifacts(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_build_artifacts_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.delete_build_artifacts_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def delete_build_artifacts_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Delete all artifacts associated with a specific build
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_build_artifacts_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_build_artifacts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `delete_build_artifacts`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `delete_build_artifacts`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `delete_build_artifacts`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `delete_build_artifacts`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/artifacts', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_audit_log(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Get audit log
        Retrieve a list of historical settings changes for this build target.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_audit_log(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :return: list[InlineResponse20011]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_audit_log_with_http_info(orgid, projectid, buildtargetid, **kwargs)
        else:
            (data) = self.get_audit_log_with_http_info(orgid, projectid, buildtargetid, **kwargs)
            return data

    def get_audit_log_with_http_info(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Get audit log
        Retrieve a list of historical settings changes for this build target.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_audit_log_with_http_info(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :return: list[InlineResponse20011]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'per_page', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_audit_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_audit_log`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `get_audit_log`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `get_audit_log`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/auditlog', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[InlineResponse20011]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_audit_log_0(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Get audit log
        Retrieve a list of settings changes between the last and current build.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_audit_log_0(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :return: list[InlineResponse20011]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_audit_log_0_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.get_audit_log_0_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def get_audit_log_0_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Get audit log
        Retrieve a list of settings changes between the last and current build.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_audit_log_0_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :return: list[InlineResponse20011]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number', 'per_page', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_audit_log_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_audit_log_0`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `get_audit_log_0`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `get_audit_log_0`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `get_audit_log_0`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/auditlog', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[InlineResponse20011]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_build(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Build Status
        Retrieve information for a specific build. A Build resource contains information related to a build attempt for a build target, including the build number, changeset, build times, and other pertinent data. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_build(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param str include: Extra fields to include in the response
        :return: OrgsorgidprojectsprojectidbuildtargetsBuilds
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_build_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.get_build_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def get_build_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Build Status
        Retrieve information for a specific build. A Build resource contains information related to a build attempt for a build target, including the build number, changeset, build times, and other pertinent data. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_build_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param str include: Extra fields to include in the response
        :return: OrgsorgidprojectsprojectidbuildtargetsBuilds
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number', 'include']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_build" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_build`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `get_build`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `get_build`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `get_build`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='OrgsorgidprojectsprojectidbuildtargetsBuilds',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_build_log(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Get build log
        Retrieve the plain text log for a specifc build.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_build_log(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param float offsetlines: Stream log from the given line number
        :param bool linenumbers: Include log line numbers in the text output
        :param float last_line_number: The last line number seen, numbering will continue from here
        :param bool compact: Return the compact log, showing only errors and warnings
        :param bool with_html: Surround important lines (errors, warnings) with SPAN and CSS markup 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_build_log_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.get_build_log_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def get_build_log_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Get build log
        Retrieve the plain text log for a specifc build.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_build_log_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param float offsetlines: Stream log from the given line number
        :param bool linenumbers: Include log line numbers in the text output
        :param float last_line_number: The last line number seen, numbering will continue from here
        :param bool compact: Return the compact log, showing only errors and warnings
        :param bool with_html: Surround important lines (errors, warnings) with SPAN and CSS markup 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number', 'offsetlines', 'linenumbers', 'last_line_number', 'compact', 'with_html']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_build_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_build_log`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `get_build_log`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `get_build_log`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `get_build_log`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []
        if 'offsetlines' in params:
            query_params.append(('offsetlines', params['offsetlines']))
        if 'linenumbers' in params:
            query_params.append(('linenumbers', params['linenumbers']))
        if 'last_line_number' in params:
            query_params.append(('lastLineNumber', params['last_line_number']))
        if 'compact' in params:
            query_params.append(('compact', params['compact']))
        if 'with_html' in params:
            query_params.append(('withHtml', params['with_html']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/log', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_builds(self, orgid, projectid, buildtargetid, **kwargs):
        """
        List all builds
        List all running and finished builds, sorted by build number (optionally paginating the results). Use '_all' as the buildtargetid to get all configured build targets. The response includes a Content-Range header that identifies the range of results returned and the total number of results matching the given query parameters. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_builds(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str include: Extra fields to include in the response
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :param str build_status: Query for only builds of a specific status
        :param str platform: Query for only builds of a specific platform
        :param bool show_deleted: Query for builds that have been deleted
        :param bool only_favorites: Query for builds that have been favorited
        :return: list[OrgsorgidprojectsprojectidbuildtargetsBuilds]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_builds_with_http_info(orgid, projectid, buildtargetid, **kwargs)
        else:
            (data) = self.get_builds_with_http_info(orgid, projectid, buildtargetid, **kwargs)
            return data

    def get_builds_with_http_info(self, orgid, projectid, buildtargetid, **kwargs):
        """
        List all builds
        List all running and finished builds, sorted by build number (optionally paginating the results). Use '_all' as the buildtargetid to get all configured build targets. The response includes a Content-Range header that identifies the range of results returned and the total number of results matching the given query parameters. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_builds_with_http_info(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str include: Extra fields to include in the response
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :param str build_status: Query for only builds of a specific status
        :param str platform: Query for only builds of a specific platform
        :param bool show_deleted: Query for builds that have been deleted
        :param bool only_favorites: Query for builds that have been favorited
        :return: list[OrgsorgidprojectsprojectidbuildtargetsBuilds]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'include', 'per_page', 'page', 'build_status', 'platform', 'show_deleted', 'only_favorites']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_builds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_builds`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `get_builds`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `get_builds`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'build_status' in params:
            query_params.append(('buildStatus', params['build_status']))
        if 'platform' in params:
            query_params.append(('platform', params['platform']))
        if 'show_deleted' in params:
            query_params.append(('showDeleted', params['show_deleted']))
        if 'only_favorites' in params:
            query_params.append(('onlyFavorites', params['only_favorites']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[OrgsorgidprojectsprojectidbuildtargetsBuilds]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_builds_for_org(self, orgid, **kwargs):
        """
        List all builds for org
        List all running and finished builds, sorted by build number (optionally paginating the results). The response includes a Content-Range header that identifies the range of results returned and the total number of results matching the given query parameters. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_builds_for_org(orgid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str include: Extra fields to include in the response
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :param str build_status: Query for only builds of a specific status
        :param str platform: Query for only builds of a specific platform
        :param bool show_deleted: Query for builds that have been deleted
        :param bool only_favorites: Query for builds that have been favorited
        :return: list[OrgsorgidprojectsprojectidbuildtargetsBuilds]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_builds_for_org_with_http_info(orgid, **kwargs)
        else:
            (data) = self.get_builds_for_org_with_http_info(orgid, **kwargs)
            return data

    def get_builds_for_org_with_http_info(self, orgid, **kwargs):
        """
        List all builds for org
        List all running and finished builds, sorted by build number (optionally paginating the results). The response includes a Content-Range header that identifies the range of results returned and the total number of results matching the given query parameters. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_builds_for_org_with_http_info(orgid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str include: Extra fields to include in the response
        :param float per_page: Number of audit log records to retrieve
        :param float page: Skip to page number, based on per_page value
        :param str build_status: Query for only builds of a specific status
        :param str platform: Query for only builds of a specific platform
        :param bool show_deleted: Query for builds that have been deleted
        :param bool only_favorites: Query for builds that have been favorited
        :return: list[OrgsorgidprojectsprojectidbuildtargetsBuilds]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'include', 'per_page', 'page', 'build_status', 'platform', 'show_deleted', 'only_favorites']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_builds_for_org" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_builds_for_org`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'build_status' in params:
            query_params.append(('buildStatus', params['build_status']))
        if 'platform' in params:
            query_params.append(('platform', params['platform']))
        if 'show_deleted' in params:
            query_params.append(('showDeleted', params['show_deleted']))
        if 'only_favorites' in params:
            query_params.append(('onlyFavorites', params['only_favorites']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/builds', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[OrgsorgidprojectsprojectidbuildtargetsBuilds]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_share(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Get the share link
        Gets a share link if it exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_share(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_share_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.get_share_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def get_share_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Get the share link
        Gets a share link if it exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_share_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `get_share`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `get_share`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `get_share`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `get_share`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='InlineResponse20015',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def revoke_share(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Revoke a shared link
        Revoke a shared link, both {buildtargetid} and {number} may use _all to revoke all share links for a given buildtarget or entire project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.revoke_share(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.revoke_share_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
        else:
            (data) = self.revoke_share_with_http_info(orgid, projectid, buildtargetid, number, **kwargs)
            return data

    def revoke_share_with_http_info(self, orgid, projectid, buildtargetid, number, **kwargs):
        """
        Revoke a shared link
        Revoke a shared link, both {buildtargetid} and {number} may use _all to revoke all share links for a given buildtarget or entire project.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.revoke_share_with_http_info(orgid, projectid, buildtargetid, number, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `revoke_share`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `revoke_share`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `revoke_share`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `revoke_share`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def start_builds(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Create new build
        Start the build process for this build target (or all targets, if '_all' is specified as the buildtargetid), if there is not one currently in process.  If a build is currently in process that information will be related in the 'error' field. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_builds(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param Options11 options: Options for starting the builds. You can specify a platform and label only when  starting a local (_local) build. A local build will return immediately and be  marked as successful. 
        :return: list[OrgsorgidprojectsprojectidbuildtargetsBuilds]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.start_builds_with_http_info(orgid, projectid, buildtargetid, **kwargs)
        else:
            (data) = self.start_builds_with_http_info(orgid, projectid, buildtargetid, **kwargs)
            return data

    def start_builds_with_http_info(self, orgid, projectid, buildtargetid, **kwargs):
        """
        Create new build
        Start the build process for this build target (or all targets, if '_all' is specified as the buildtargetid), if there is not one currently in process.  If a build is currently in process that information will be related in the 'error' field. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_builds_with_http_info(orgid, projectid, buildtargetid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param Options11 options: Options for starting the builds. You can specify a platform and label only when  starting a local (_local) build. A local build will return immediately and be  marked as successful. 
        :return: list[OrgsorgidprojectsprojectidbuildtargetsBuilds]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'options']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_builds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `start_builds`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `start_builds`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `start_builds`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'options' in params:
            body_params = params['options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[OrgsorgidprojectsprojectidbuildtargetsBuilds]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_build(self, orgid, projectid, buildtargetid, number, options, **kwargs):
        """
        Update build information
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_build(orgid, projectid, buildtargetid, number, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param Options12 options: Options for build update (required)
        :return: OrgsorgidprojectsprojectidbuildtargetsBuilds
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_build_with_http_info(orgid, projectid, buildtargetid, number, options, **kwargs)
        else:
            (data) = self.update_build_with_http_info(orgid, projectid, buildtargetid, number, options, **kwargs)
            return data

    def update_build_with_http_info(self, orgid, projectid, buildtargetid, number, options, **kwargs):
        """
        Update build information
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_build_with_http_info(orgid, projectid, buildtargetid, number, options, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str orgid: Organization identifier (required)
        :param str projectid: Project identifier (required)
        :param str buildtargetid: unique id auto-generated from the build target name (required)
        :param str number: Build number or in some cases _all (required)
        :param Options12 options: Options for build update (required)
        :return: OrgsorgidprojectsprojectidbuildtargetsBuilds
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['orgid', 'projectid', 'buildtargetid', 'number', 'options']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_build" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'orgid' is set
        if ('orgid' not in params) or (params['orgid'] is None):
            raise ValueError("Missing the required parameter `orgid` when calling `update_build`")
        # verify the required parameter 'projectid' is set
        if ('projectid' not in params) or (params['projectid'] is None):
            raise ValueError("Missing the required parameter `projectid` when calling `update_build`")
        # verify the required parameter 'buildtargetid' is set
        if ('buildtargetid' not in params) or (params['buildtargetid'] is None):
            raise ValueError("Missing the required parameter `buildtargetid` when calling `update_build`")
        # verify the required parameter 'number' is set
        if ('number' not in params) or (params['number'] is None):
            raise ValueError("Missing the required parameter `number` when calling `update_build`")
        # verify the required parameter 'options' is set
        if ('options' not in params) or (params['options'] is None):
            raise ValueError("Missing the required parameter `options` when calling `update_build`")


        collection_formats = {}

        path_params = {}
        if 'orgid' in params:
            path_params['orgid'] = params['orgid']
        if 'projectid' in params:
            path_params['projectid'] = params['projectid']
        if 'buildtargetid' in params:
            path_params['buildtargetid'] = params['buildtargetid']
        if 'number' in params:
            path_params['number'] = params['number']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'options' in params:
            body_params = params['options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain', 'text/html', 'text/csv'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['apikey', 'permissions']

        return self.api_client.call_api('/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='OrgsorgidprojectsprojectidbuildtargetsBuilds',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
